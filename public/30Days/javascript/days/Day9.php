<?php
$Name_Page = str_replace('.php', '', basename(__FILE__));
$Name_File = 'JavaScript';
?>
<!doctype html>
<html lang="fa" dir="rtl">
<head>
    <?php include MAIN_DIR . "public/Main/meta-main.php" ?>
    <link rel="stylesheet" href="<?= MAIN_SERVER . 'assets/css/FullStyle.css' ?>">  <!-- Style Main seed -->
    <link rel="stylesheet" href="<?= MAIN_SERVER . 'public/30Days/style.css' ?>">  <!-- Style This Page -->
    <link rel="stylesheet" href="<?= MAIN_SERVER . 'assets/vendor/prism.css' ?>">  <!-- Style Prism Library -->
    <title> <?= $Name_Page . ' ' . $Name_File ?>  </title>
</head>
<body>

<!-- HEADER -->
<?php require MAIN_DIR . "public/Main/Header.php" ?>
<!-- END HEADER -->


<!-- MAIN -->
<?php
// Number Of Day
$test = str_replace("day", '', $Name_Page);
$test = [$test - 1, $test + 1, $test]; // 0 -> Pre  , 1 -> Nex , 2 -> Current
?>
<!-- Subject -->
<section class="container subject">
    <h1>
        <?= "$Name_File 30 Days" ?> (جاوا اسکریپت در 30 روز)
        -
        روز
        <?= $test[2] ?>
        <br>
        &gt;&gt;
        توابع مرتبه بالا و کالبک فانکشن ها
    </h1>
    <p>راهنمای قدم به قدم برای تبدیل شدن به برنامه نویس جاوا اسکریپت در <b>30 روز</b></p>
    <br>
    <div class="row options">
        <div class="col-xs-12 col-s-12 col-l-6">
            <a href="<?= MAIN_SERVER ?>">تمامی نقشه راه ها</a>
        </div>
        <div class="col-xs-12 col-s-12 col-l-6" style="text-align: left">
            <a href='<?= MAIN_GITHUB . "/issues/new?title=[Suggestion] $Name_File Developer - 30Days" ?>'
               target="_blank">پیشنهاد
                تغییر - نقشه راه بهتر</a>
        </div>
    </div>
    <section class="between">
        <hr class="between">
        <h2><a href="<?= MAIN_SITE ?>" target="_blank">Subscribe</a></h2>
        <h2><a href="<?= site_url($Name_File) ?>"><?= $Name_File ?></a></h2>
        <h2>Day <?= $test[2] ?></h2>
    </section>
</section>

<!-- Start Previous and Next Days -->
<div class="container Pre_Nex">
    <div class="row">
        <a href="<?= 'day' . $test[1]?>" class="col-xs-5 col-md-2">
            &rarr;
            روز بعدی (
            <?= $test[1] ?>
            )
        </a>
        <div class="col-xs-2 col-md-8"></div>
        <a href="<?= 'day' . $test[0]?>" class="col-xs-5 col-md-2">
            روز قبلی (
            <?= $test[0] ?>
            )
            &larr;
        </a>
    </div>
</div>
<!-- End Previous and Next Days -->

<br>
<!-- Start List -->
<section class="container list30days">
    <ul>
        <li><a href="#day-9">روز نهم</a>
            <ul>
                <li><a href="#higher-order-function">توابع مرتبه بالا (Higher Order Function)</a>
                    <ul>
                        <li><a href="#callback">مفهوم Callback</a></li>
                        <li><a href="#returning-function">عملکرد برگشتی (Returning function)</a></li>
                        <li><a href="#setting-time">تنظیم زمان (Setting time)</a>
                            <ul>
                                <li><a href="#setting-interval-using-a-set-interval-function">تنظیم زمان با استفاده از setInterval</a></li>
                                <li><a href="#setting-a-time-using-a-set-timeout">تنظیم زمان با استفاده از setTimeout</a></li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li><a href="#functional-programming">برنامه نویسی تابعی (Functional Programming)</a>
                    <ul>
                        <li><a href="#foreach">forEach</a></li>
                        <li><a href="#map">map</a></li>
                        <li><a href="#filter">filter</a></li>
                        <li><a href="#reduce">reduce</a></li>
                        <li><a href="#every">every</a></li>
                        <li><a href="#find">find</a></li>
                        <li><a href="#findindex">findIndex</a></li>
                        <li><a href="#some">some</a></li>
                        <li><a href="#sort">sort</a>
                            <ul>
                                <li><a href="#sorting-string-values">مرتب سازی رشته ها</a></li>
                                <li><a href="#sorting-numeric-values">مرتب سازی اعداد</a></li>
                                <li><a href="#sorting-object-arrays">مرتب سازی آرایه / شی</a></li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li><a href="#-exercises">💻 تمرینات</a></li>
            </ul>
        </li>
    </ul>
</section>
<!-- End List -->

<!-- Start Article -->
<article class="container">
    <h1 id="day-9">روز نهم</h1>
        <h1 id="higher-order-function">توابع مرتبه بالا (Higher Order Function)</h1>
            <div>
                <p>
                    تا به الان با مفهوم های زیادی آشنا شدیم ، اما امروز قراره چیزایی که یاد گرفتیم رو یکمی پیشرفته‌تر کنیم تا بیشتر به دردمون بخوره؛
                    یکی از مباحث Higher Order Function که یعنی تابعی داریم که یکی از آرگومان های همین تابع ، تابعی دیگه اییه! یعنی تابع ما خودش یه تابع میگیره و در آخرم یه تابع خروجی میده.
                    این مبحث برای توضیح دادن یکمی سخته و بهتره با مثال این مورد رو بهتون توضیح بدم!
                </p>
            </div>
            <h2 id="callback">مفهوم Callback</h2>
                <div>
                    <p>
                        اولین بخش در مورد توابع مرتبه بالا callback ، کالبک همونجوری که از اسمش پیداست یعنی تابعی که بهش یه تابع دیگه رو پاس میدیم
                        برای درک بهتر این زیر روی مثال توضیح میدم چون این بخش یکم توضیح دادنش برای خودمم سخته!!
                    </p>
                    <pre>
                        <code>
                            const callback = (n) => {
                                return n ** 2 ;
                            }
                            // ما یه تابع پیکانی ایجاد کردیم که یه آرگومان میگیره و اونو به توان 2 میرسونه

                            function cube(callback, n) {
                                return callback(n) * n ;
                            }
                            // اینجا هم یه تابع دیگه ایجاد کردیم که آرگومان اول یه تابع میگیره و در آخر مقدار اون تابع رو ضبدر یه متغیر دیگه میکنه
                            // توجه کنید که ما آرگومان دوم رو به آرگومان تابع کالبک پاس دادیم

                            console.log(cube(callback, 3)) // Print : 27
                        </code>
                    </pre>
                    <b>
                        توجه به دو نکته داشته باشید ، اول اینکه هر اسمی میتونید برای تابع ها بزارید ولی بهتره برای تابعی که از کالبک استفاده میکنه از کلمه callback استفاده کنید
                        تا یادتون بمونه این تابع متغیر نمیگرفت! و مورد دوم هم اینکه طریقه کار توابع کالبک به این صورته که اول تابع درونی صدا زده میشه
                        و بعد تابع بیرونی (یعنی اول مقدار تابع کالبک محاسبه میشه و بعد مقدار تابع اصلی بدست میاد)
                    </b>
                    <pre>
                        <code>
                            // یه مثال دیگه میزنم این پایین ولی نحوه کارشو فک کنید چجوریه
                            const myFunkCallBack = (a,b) => {
                                return ((a + b) / 2 );
                            }
                            function mainFunk (callback , a , b) {
                                return callback(a,b) * callback(a,b)
                            }

                            console.log(mainFunk(myFunkCallBack,4,6))  // Print : 25
                        </code>
                    </pre>
                </div>
            <h2 id="returning-function">عملکرد برگشتی (Returning function)</h2>
                <div>
                    <p>
                        حالا که معنی کالبک رو میدونیم ، برسیم سر همون توابع مرتبه بالا که فرق این توابع اینه که علاوه بر گرفتن یه تابع ، یه تابع رو هم برمیگردونن مثل زیر :
                    </p>
                    <pre>
                        <code>
                            const higherOrder = n => {
                                const doSomething = m => {
                                    const doWhatEver = t => {
                                        return n * m * t
                                }
                                return doWhatEver
                              }
                              return doSomething
                            }
                            console.log(higherOrder(2)(3)(10))  // Print : 60
                        </code>
                    </pre>
                    <b>
                        به احتمال بالا با دیدن کدهای بالا یکم جا خوردید ، که چی شد؟ بیاید از اول بررسی کنیم ببینیم داستان از چه قراره (به بررسی کدهامون از بالا به پایین میگیم trace کردن ، اینجوری درک بهتری از کدهامون پیدا میکنیم)
                        <br>
                        در قسمت اول یه تابع ایجاد کردیم با یه آرگومان به نام n ،
                        داخل همین تابع یه تابع دیگه تعریف میکنیم به نام doSomething که این تابع هم یه آرگومان به نام m میگیره و دوباره داخل همین تابع یه تابع دیگه تعریف میکنیم به
                        نام doWhatEver که این تابع هم یه آرگومان دیگه میگیره (3 تا تابع تو در تو داریم که هرکدومش یه آرگومان میگیره ، پس تابع اصلی نیاز به 3 تا آرگومان داره)
                        <br>
                        تابع آخری که تعریف کردیم دیگه داخلش تابع دیگه ایی وجود نداره و ضرب تمامی آرگومان هامون رو برمیگردونه (یعنی الان ضرب همه آرگومان هامون داخل متغیر doWhatEver ذخیره شده) ، حالا برای استفاده از این مقدار
                        باید این متغیر رو برگردونیم پس از return doWhatEver استفاده میکنیم ، با این کار مقدار doWhatEver به تابع doSomething فرستاده میشه ، ولی هنوز کار داریم
                        و دوباره باید این مقدار هم برگردونیم تا تابع higherOrder یه مقدار بازگشتی داشته باشه.
                        <br>
                        ممکنه یکم گیج شده باشید اما چند بار این متن رو بخونید تا متوجه بشید ، در واقع هر تابع داخل خودش یه تابع دیگه رو تعریف میکنه و در آخر
                        مقدار همون تابع رو برمیگردونه.
                    </b>
                    <pre>
                        <code>
                            // اینم یه مثال جالب تر که میتونید بررسیش کنید
                            const number = [1,2,3,4,5]
                            const sumArray = (arr) => {
                                let sum = 0 ;
                                const callback = function(element) {
                                    sum += element
                                }
                                for (const elem of arr) {
                                    callback(elem)
                                }
                                return sum
                            }
                            console.log(sumArray(number)) // Print : 15
                        </code>
                    </pre>
                </div>
            <h2 id="setting-time">تنظیم زمان (Setting time)</h2>
                <div>
                    <p>
                        حالا که در مورد تابع های مرتبه بالا و کالبک فانکشن ها اطلاعات داریم ، میرسیم به چنتا تابع مهم! دوتا تابع میخوایم معرفی کنیم که callback میگیرن
                        و قراره باهاشون کارهای جالبی انجام بدیم!
                    </p>
                </div>
                <h3 id="setting-interval-using-a-set-interval-function">تنظیم زمان با استفاده از setInterval</h3>
                    <div>
                        <p>
                            خب تا حالا توابع زیادی یاد گرفتیم ، اما فرض کنید میخواید بعد از 10 ثانیه یچیزی رو توی کنسول چاپ کنید و نمیخواید دقیقا همون لحظه اجرا بشه! اونوقت نیاز به تابعی داریم
                            که الان میخوایم بررسیش کنید! تابع setInterval ، تابعیه که ما میتونیم باهاش کارامون رو به صورت مداوم در بازه زمانی مشخص انجام بدیم (یعنی مثلا میخوایم هر 5 ثانیه یک بار توی کنسول سلام رو چاپ کنیم) :
                        </p>
                        <pre>
                            <code>
                                // سیتکس کلی این تابع ایمجوریه
                                function callback() { // تابعی که میخواید به صورت مداوم اجرا بشه
                                    // کد های شما
                                }
                                setInterval(callback , duration)

                                // آرگومان اول همون تابعیه که میخواید اجرا بشه و آرگومان دوم مدت زمان هر تکرار رو مشخص میکنه
                            </code>
                        </pre>
                        <pre>
                            <code>
                                function salam() {
                                    console.log('سلام')
                                }
                                setInterval(salam , 1000)
                                // آرگومان دوم رو به میلی ثانیه میدیم (هر 1000 میلی ثانیه یک ثانیه است)
                                // الان هر 1 ثانیه توی کنسول سلام چاپ میشه
                                // توجه کنید که تا بی نهایت ادامه داره
                            </code>
                        </pre>
                    </div>
                <h3 id="setting-a-time-using-a-set-timeout">تنظیم زمان با استفاده از setTimeout</h3>
                    <div>
                        <p>
                            تابع بالا به صورت مداوم دستورات شما رو اجرا میکنه ، اما اگه بخواید یبار اجرا بشه باید چیکار کنید؟ خب یه تابع دیگه داریم
                            که این تابع هم سیسنتکسش دقیقا مثل بالاییه ولی فقط یبار اجرا میشه :
                        </p>
                        <pre>
                            <code>
                                function salam() {
                                    console.log('سلام')
                                }
                                setTimeout(salam, 2000) // بعد از 2 ثانیه ، فقط یکبار سلام رو توی کنسول چاپ میکنه
                            </code>
                        </pre>
                        <b>
                            جلسات بعدی با این توابع بیشتر آشنا میشیم ، ولی میتونید سرچ بزنید و اطلاعاتتونو از قبل بالا ببرید تا به مبحثش برسیم!
                        </b>
                    </div>
        <h1 id="functional-programming">برنامه نویسی تابعی (Functional Programming)</h1>
            <div>
                <p>
                    مبحث توابع مرتبه بالا از شیوه برنامه نویسی تابعی ایجاد شده.ولی اصلا شیوه برنامه نویسی چیه ؟ بحث شیوه برنامه نویسی برای توضیحا دادن توی اینجا نیست و بهتره سرچ کنید
                    تا بهتر یاد بگیرید ولی به صورت کلی شیوه برنامه نویسی همونجوری که از روی اسمش پیداست یعنی با استفاده از چه الگویی کد بنویسیم. و توی برنامه نویسی تابعی یعنی رویکرد برنامه نویسمون
                    بر پایه محسابات و استفاده های مکرر از توابع مختلفه(شیوه های برنامه نویسی دیگه ایی هم داریم مثل شی گرا یا برنامه نویسی اعلانی که هر کدوم شیوه و هدف متفاوتی دارن)
                    <br>
                    در این قسمت میخوایم با بعضی از توابع آشنا بشیم که توی برنامه نویسی تابعی بهمون کمک میکنه و میتونه پیچیدگی برناممون رو تا حد زیادی کم کنه!
                </p>
            </div>
            <h2 id="foreach">forEach</h2>
                <div>
                    <p>
                        قبلا در مورد حلقه ها حرف زدیم و گفتیم میتونیم از حلقه for به شکلی استفاده کنیم که از ایندکس اول تا آخر آرایه رو برامون تکرار کنه ؛اما تابعی داریم که این کار رو برامون خیلی ساده‌تر میکنه
                        ینی پیچدگی حلقه for رو تا حد زیادی پایین میاره و حتی نوشتن راحت تری داره و اسم اون تابع چیزی نیست جز forEach!
                    </p>
                    <pre>
                        <code>
                            const number = [1,2,3,4,5];

                            number.forEach(num => console.log(num))
                            // قبل از مشاهده سینتکس اینو نگاه کنید و با این زیری مقایسه کنید

                            for (const num as number) {
                                console.log(num);
                            }

                            // جفت کدها یکار رو میکنن
                        </code>
                    </pre>
                    <pre>
                        <code>
                            /*
                            سینتسک کلی این تابع خیلی راحته ، آرایه ایی که میخواید روش تکرار رو انجام بدید رو مینویسید و از کلمه کلیدی
                            forEach
                            بعد از اون استفاده میکنید ، و در آرگومان هم یه تابع ناشناس تعریف میکنید و کاری که میخواید تکرار بشه
                            رو داخل اون مینویسد به همین راحتی
                            */

                            const number = [1,2,3,4,5];
                            number.forEach(num => console.log(num))
                            /*
                            ببنید ما یه آرایه با 5 عضو ساختیم
                            بعد از فورایچ استفاده کردیم و به عنوان آرگومان بهش یه تابع پیکانی دادیم که یه آرگومان داره ؛ آرگومان
                            num
                            همون اعضای آرایه رو در هر دور مشخص میکنه ، دقیقا مثل حلقه
                            for
                            که اعضا رو به صورت زیر مشخص میکردیم
                            const array as element
                            */


                            let sum = 0;
                            const numbers = [1, 2, 3, 4, 5];
                            numbers.forEach(num => sum += num)

                            console.log(sum) // Print : 15
                        </code>
                    </pre>
                    <pre>
                        <code>
                            // توجه کنید که سیتکس کلی این تابع به این صورته
                            const numbers = [1, 2, 3, 4, 5];
                            numbers.forEach((element, index, numbers) => {
                                console.log(element, index, numbers)
                            })

                            /* Print :
                            1 0 (5)[1, 2, 3, 4, 5]
                            2 1 (5)[1, 2, 3, 4, 5]
                            3 2 (5)[1, 2, 3, 4, 5]
                            4 3 (5)[1, 2, 3, 4, 5]
                            5 4 (5)[1, 2, 3, 4, 5]
                            */
                        </code>
                    </pre>
                    <b>
                        آرگومان اول یعنی element در هر دور یک عضو از آرایه رو میگیره ، آرگومان دوم یعنی index در هر دور مقدار اندیس یا همون ایندکس
                        هر عضو رو برمیگردونه (یعنی در دور اول 0 و در دور دوم 1 و الی آخر رو برمیگردونه) و همچنین آرگومان سوم خود آرایه رو برمیگدونه!
                        <br>
                        تابع callback که به عنوان ورودی به متد فیلتر پاس میدیم شامل سه آرگومان ورودی میشه که آرگومان element اجباری و دو آرگومان index و array با توجه به کاری که قراره انجام بدیم اختیاری هستن.
                        توجه کنید که تابع map و filter هم به همین صورته!
                        <br>
                        و همینطور میتونید اسم آرگومان هارو خودتون اختیاری عوض کنید ، اما بهتره چیزی بزارید که مرتبط باشه!
                    </b>
                </div>
            <h2 id="map">map</h2>
                <div>
                    <p>
                        خب خب خب ، یکی دیگه از تابع های باحالمون تابع map ، این تابع هم دقیقا سینتکس شبیه به forEach داره ، با این فرق که
                        فورایچ حالت حلقه داره ولی داخل map میتونید هر عضو آرایه رو به یه آرایه دیگه نسبت بدید (یه به طور ساده تر : این متد یک آرگومان به صورت یک تابع کال‌بک دریافت میکنه، اون رو روی تک تک عناصر آرایه اعمال میکند و در پایان ، نتیجه را به صورت یک آرایه جدید برمیگردونه. پس در واقع این تابع هیچ اثر جانبی بر روی آرایه‌ای که بر روی آن اجرا شده نمیذاره و فقط یک آرایه جدید میسازه و برمیگردونه.)
                        این زیر مثال میزنم تا بهتر متوجه کار این تابع بشید :
                    </p>
                    <pre>
                        <code>
                            const numbers = [1, 2, 3, 4, 5]
                            const numbersSquare = numbers.map((num) => num * num)
                            console.log(numbersSquare) // Print : [1,4,9,16,25]

                            /*
                            ما تو قسمت اول یه آرایه با 5 عضو ایجاد کردیم و بعد از تابع مَپ استفاده کردیم
                            نحوه کار این تابع به این صورته که یه تابع بهش پاس میدیم و هر کاری که توی تابع انجام میدیم
                            توی یه آرایه جدید ذخیره میشه
                            مثلا توی مثال بالا اول عدد 1 وارد تابع میشه به عنوان آرگومان بعد ضبدر خودش میشه که میشه 1
                            این 1 میره تو اندیس 0 متغیر
                            numbersSquare
                            توی دور بعدی عدد 2 قرار میگیره و ضبدر خودش میشه یعنی عدد 4 و عدد 4 هم میره تو اندیس 1 متغیر
                            و همینطوری تا آخر آرایه ادامه پیدا میکنه
                            */

                            // اینم یه مثال دیگه
                            const names = ['Amir', 'Mathias', 'Elias', 'Brook']
                            const namesToUpperCase = names.map((name) => name.toUpperCase())
                            console.log(namesToUpperCase)  // Print : ['AMIR', 'MATHIAS', 'ELIAS', 'BROOK']
                        </code>
                    </pre>
                    <b>
                        توجه کنید که این تابع هم دقیقا مثل تابع forEach میتونه 3 تا آرگومان بگیره و دقیقا هم مثل همون تابع رفتار میکنه!
                    </b>
                </div>
            <h2 id="filter">filter</h2>
                <div>
                    <p>
                        ساختار کلی این متد به این صورته که به عنوان ورودی یک تابع callback میگیره که ما شرط خودمون رو داخل این تابع می نویسیم و بعد تابع callback رو یک به یک برای تمامی آیتم های یک آرایه اجرا میکنه و آیتم هایی که شرط رو پاس کردن در قالب یک آرایه جدید به ما برمی گردونه.
                        <br>
                        این مورد رو هم باید توی مثال زیر ببیند و حتما خودتون تست کنید تا قشنگ متوجه کارش بشید :
                    </p>
                    <pre>
                        <code>
                            const myArray = [16 , 8 , 17 , 14 , 12 , 13 , 25 , 18]
                            const result = myArray.filter(element => element > 20)
                            console.log(result) // Print : [25]

                            // توجه کنید که این تابع هم مثل تابع مَپه با این فرق که اینجا بر اساس شرط کار میکنه
                            // پس حتما حواستون باشه باید داخل این تابع حتما یه شرطی که درست یا نادرست برمیرگردونه انتخاب کنید


                            /*
                            یاددتون باشه فقط وقتی که یه خط دستور داریم از کلمه کلیدی
                            return
                            استفاده نمیکنیم ، اگر چند خط داشتیم باید از ریترن استفاده کنیم و همچنین آکولاد هم یادتون نره
                            */
                        </code>
                    </pre>
                    <pre>
                        <code>
                            // اینم یه مثال دیگه از این تابع
                            const country = ['Iran' , 'England' , 'Netherland' , 'Fenland' , 'New Zealand' , 'USA' ,'Germany']
                            const result = country.filter((element) =>  element.includes('land'))
                            console.log(result) // Print : ['England', 'Netherland', 'Fenland', 'New Zealand']
                        </code>
                    </pre>
                </div>
            <h2 id="reduce">reduce</h2>
                <div>
                    <p>
                        یه تابع میخوایم معرفی کنیم که واقعا توضیح دادن به صورت فارسی براش سخته ، پس حرف اضافی نمیزنم و دقیقا با یه مثال کلشو توضیح میدم :
                    </p>
                    <pre>
                        <code>
                            const myArray = [1,2,3,4,5]
                            const sum = myArray.reduce((total , next) => total + next , 0)
                            console.log(sum) // Print : 15

                            // برای بهتر متوجه شدن میتونید جای استفاده از تابع پیکانی از تابع ساده استفاده کنید
                            const myArray = [1,2,3,4,5]
                            const sum = myArray.reduce(check , 0)
                            function check (total , next) {
                                return total + next ;
                            }
                            console.log(sum) // Print : 15
                        </code>
                    </pre>
                    <b>
                        تابع بالا هم مثل تابع های قبلی یه کالبک فانکشن به عنوان پارامتر اول میگیره (پارامتر دوم مقدار اولیه total) که اون تابع کالبک هم خودش باید دوتا آرگومان داشته باشه.
                        حالا دقیقا کار این تابع چیه؟ ما دوتا پارامتر به نام total و next ایجاد کردیم ، تابع reduce یه کار ثابت انجام میده ، پارامتر total مقدار کلیه که توی دور اول آرایه برابر با صفره
                        ، پارامتر دوم یعنی next عضو آرایه رو نشون میده که توی دور اول برابر با یکه (پارامتر دوم تابع reduce مشخص کننده شروعه) ، حالا ما total و با next جمع میکنیم
                        که میشه 0 + 1 = 1 پس توی دور اول مقدار شد 1 (این 1 برای دور بعدی داخل total ذخیره میشه) ، حالا میرسیم به دور دوم
                        مقدار total برابر با 1 میشه و متغیر بعدی هم 2 ، حالا دوباره 2 با 1 جمع میشه و مقدار درون total ریخته میشه ، این بازی تا آخر ادامه پیدا میکنه
                        تا عضوی از آرایه باقی نمونه! و در آخر هم مقدار total رو برمیگردونه :)
                        <br>
                        شاید یکمی براتون پیچیده شده باشه این توابع ولی نگران نباشید ، میتونید سرچ کنید و یاد بگیرد چون واقعا نمیشه گفت راحتن! در هر صورت
                        کار این تابع چند مورده : پارامتر اول یه تابع کالبک با دوتا آرگومان الزامی میگیره و پارامتر دوم مقدار اولیه رو مشخص میکنه (اگر خالی باشع ، پیشفرض مقدار اول رو دریافت میکنه). تابع کالبکی هم که به این تابع پاس دادیم
                        دو تا پارامتر الزامی داره که پارامتر اول مقدار محاسبه شده در هر دوره (که میشه توی پارامتر دوم تابع reduce بهش مقدار اولیه داد) ، و پارامتر بعدی عضو بعدی آرایه است(اگر پارامتر دوم تابع reduce که برای مقدار پیشفرض بود رو قرار ندید ، این مقدار هم توی دور اول به جای ایندکس 0 از ایندکس 1 شروع میکنه) ، یه مثال این زیر دارم براتون :
                    </b>
                    <pre>
                        <code>
                            // فرض کنید یه آرایه داریم و میخوایم اعضاشون رو از هم کم کنیم ، به دو روش این کارو انجام میدم
                            const myArray = [526 , 223 , 87 , 13 , 11]

                            // روش اول
                            let lowOff = myArray[0];
                            for (let i = 0 ; i < myArray.length ; i++) {
                                if(i==0) continue
                                lowOff -= myArray[i] ;
                            }
                            console.log(lowOff)

                            // روش دوم
                            const result = myArray.reduce((total,next) => total - next)
                            console.log(result)

                            // جواب هر دو روش یکی میشه ، اما صد درصد دومین روش راحت تره
                        </code>
                    </pre>
                    <b>
                        توجه کنید که توی مثال بالا با فقط یه تابع کالبک به تابع reduce دادیم و آرگومان دوم رو پر نکردیم ، پس توی دور اول total برابر اندیس 0 آرایه یعنی 526 میشه و
                        next هم برابر اندیس 1 آرایه یعنی 223 میشه ، که اینجوری توی دور اول 526 منهای 223 میشه و مقدار توی total ذخیره میشه و همینجوری تا پایان آرایه ادامه پیدا میکنه.
                        <br>
                        توی دور دوم total برابر 303 و مقدار next برابر 87 میشه ، که دوباره 303 منهای 87 میشه و توی total قرار میگیره!
                        <br>
                        شاید بپرسید این تابع اصن چرا باید استفاده بشه؟ یه موردشو که دیدیم ، حجم کد نویسیون رو خیلی میاره پایین! دوم اینکه این تابع روشه reduce (کاهشی)
                        پس یعنی برای عملیات های کاهشی روی تابع خیلی پر استفاده است! سوم اینکه میتونید یه آرایه رو با الگوریتم های مختلف به یه عدد ثابت تبدیل کنید (مثلا برای ضرب مجموع اعضا ، جمع و تفریق اعضا و غیره کاربرد داره)
                    </b>
                </div>
            <h2 id="every">every</h2>
                <div>
                    <p>
                        حالا یه تابع خیلی ساده رو بررسی میکنیم که یکم از فاز پیچدگی هم بیایم بیرون؛ تابع every یه کالبک فانکشن به عنوان پارامتر میگیره
                        و کارش اینه که تست کنه اعضای یک آرایه همشون یه نوع داده دارن یا نه ، اینم مثالش :
                    </p>
                    <pre>
                        <code>
                            const names = ['Amir', 'Mathias', 'Elias', 'Brook']
                            const areAllStr = names.every((name) => typeof name === 'string')

                            console.log(areAllStr)  // Print : true


                            const bools = [true, true, false, true]
                            const areAllTrue = bools.every((b) => b === true)

                            console.log(areAllTrue) // Print : false
                        </code>
                    </pre>
                </div>
            <h2 id="find">find</h2>
                <div>
                    <p>
                        یه تابع ساده دیگه هم داریم به نام find که مثل تابع filter یه شرط میگیره و اولین عنصری که شرط براش درست بود رو برمگیردونه ،
                        مثلا چنتا اسم دانش آموز دارید و میخواید ببیند اولین نفرسی که اسمش با z شروع شده کیه :
                    </p>
                    <pre>
                        <code>
                            const array = ['Ayda','Zahra','Shadi','Faranak','Yeganeh','Ziba']
                            const firstZName = array.find(element => element.includes('Z'))
                            console.log(firstZName)  // Print : Zahra
                        </code>
                    </pre>
                </div>
            <h2 id="findindex">findIndex</h2>
                <div>
                    <p>
                        این تابع هم دقیقا مثل تابع بالایی ولی به جای برگردوندن خود عنصر ، ایندکس اون عنصر رو برمیگردونه ، مثلا همون چنتا دانش آموز رو میخوایم ببینم
                        اولین نفری که اسمش با z شروع شده چندمیه :
                    </p>
                    <pre>
                        <code>
                            const array = ['Ayda','Zahra','Shadi','Faranak','Yeganeh','Ziba']
                            const firstZName = array.findIndex(element => element.includes('Z'))
                            console.log(firstZName)  // Print : 1
                        </code>
                    </pre>
                </div>
            <h2 id="some">some</h2>
                <div>
                    <p>
                        این تابع هم دقیقا مثل every کار میکنه با این تفاوت که شرط رو روی تمام اعضا چک نمیکنه ، و اگه یه عضو از آرایه هم شرطش درست بود
                        مقدار true رو برمیرگدونه (میشه گفت یجوری تلفیق بین تابع های filter و every) :
                    </p>
                    <pre>
                        <code>
                            const array = ['Amir' , 'Alex' , 'Ahmad' , 'Arthur' , 'Bizhan']
                            const result = array.some(element => element.includes('Bi'))
                            console.log(result) // Print : true
                        </code>
                    </pre>
                </div>
            <h2 id="sort">sort</h2>
                <div>
                    <p>
                        یادتونه تو چند جلسه پیش در مورد مرتب سازی و تابع sort حرف زدیم؟ یادتون نمیاد؟واقعا که! به هر حال قبلا حرف زدیم و گفتیم این تابع به صورت پیشفرض
                        برای رشته ها خوب کار میکنه ، اما برای اعداد نه! حالا رسیدیم جایی که این تابع روباز ترش کنیم ، و بهتون بگیم این تابع هم از اون تابع هاییه که یه تابع کالبک به عنوان پارامتر میگیره (وقتی یه تابع ، یه تابع دیگه رو به عنوان پارامتر میگیره به صورت کلی میگیم اون تابع کالبک میگیره!)
                    </p>
                </div>
                <h3 id="sorting-string-values">مرتب سازی رشته ها</h3>
                    <div>
                        <p>
                            مرتب سازی رشته ها رو که قبلا دیدیم ، ینی به صورت پیشفرض اگه به تابع sort چیزی پاس ندیم ، خودش رشته های آرایه ما رو مرتب میکنه :
                        </p>
                        <pre>
                            <code>
                                const products = ['Milk', 'Coffee', 'Sugar', 'Honey', 'Apple', 'Carrot']
                                console.log(products.sort()) // ['Apple', 'Carrot', 'Coffee', 'Honey', 'Milk', 'Sugar']
                            </code>
                        </pre>
                    </div>
                <h3 id="sorting-numeric-values">مرتب سازی اعداد</h3>
                    <div>
                        <p>
                            برای مرتب سازی اعداد ما باید یه تابع بنویسیم تا این کار رو برامون انجام بده و یه الگوریتم داشته باشه (برای مرتب سازی اعداد تو دنیای واقعی دوتا دوتا اعداد رو مقایسه میکنیم و هرکدوم کوچیک تر بود رو اول میزاریم) :
                        </p>
                        <pre>
                            <code>
                                const numbers = [9.81, 3.14, 100, 37, 13]
                                console.log(numbers.sort()) // [100, 3.14, 37, 9.81]
                                // همینجوری استفاده کنیم بد مرتب میکنه ، چون بر اساس رشته این کارو میکنه

                                numbers.sort(function (a, b) {
                                    return a - b
                                })
                                /*
                                تابع بالایی که به سورت پاس دادیم ، دوتا پارامتر اِی و بی داره که به ترتیب عضو اول و دوم آرایه هستن
                                وقتی نوشتیم اِی منهای بی یعنی مقایسه کن عضو اول رو با دوم ، وقتی دوتا عدد رو منهای هم میکنیم
                                یا 0 میشه یا مثبت میشه یا منفی میشه (از این 3 تا حالت خارج نیست) تو اینجا هم اگه مقایسه دوتا عدد
                                برابر با 0 شد ، جابه جایی رخ نمیده ، اگه منفی شد ، یعنی عدد اول کوچیک تر از عدد دومه پس سر جاش میمونه
                                اگه مثبت شد ، یعنی عدد اول بزرگ تر از عدد دومه پس با عضو بعدی جابه جا میشه
                                توی دور اول هم 9.81 با 3.14 مقایسه میشه و چون جواب مثبت میشه جای خونه هاشون عوض میشه
                                پس ترتیی تا الان میشه 13 , 37 , 100 , 9.18 , 3.14 ، حالا میره عضو دوم رو با سومی مقایسه میکنه
                                یعنی 9.18 رو با 100 و چون مقایسه میشه منفی ، پس عدد سرجاش میمونه و میره باری دور بعدی
                                این کار همینجوری ادامه پیدا میکنه تا دوتا عضو آخر
                                حواستونم باشه با این کار اعداد رو از کوچیک به بزرگ مرتب میکنیم
                                */
                                console.log(numbers) // [3.14, 9.81, 37, 100]

                                numbers.sort(function (a, b) {
                                    return b - a
                                })
                                /*
                                اینم دقیقا مثل همون بالایی ، فقط ایندفعه بی رو منهای اِی کردیم
                                با این کار عدد دوم با عدد اول مقایسه میشه و همین کار باعث میشه ایندفعه مرتب سازی نزولی بشه
                                و از بزرگ به کوچیک مرتب شه
                                به همین راحتی
                                */
                                console.log(numbers) // [100, 37, 9.81, 3.14]
                            </code>
                        </pre>
                    </div>
                <h3 id="sorting-object-arrays">مرتب سازی آرایه / شی</h3>
                    <div>
                        <p>
                            برای مرتب سازی اشیا هم میتونید دقیقا از تابع بالا استفاده کنید (تابعی که به sort پاس میدید دوتا آرگومان داره که عضو اول و دوم رو مشخص میکنن) ، فقط با
                             این فرق که برای مرتب سازی آرایه ها ما به کلیدشون (key) نیاز داریم :
                        </p>
                        <pre>
                            <code>
                                objArr.sort(function (a, b) {
                                    if (a.key < b.key) return -1
                                    if (a.key > b.key) return 1
                                    return 0
                                })
                                /*
                                اینم دقیقا عضو اول و دوم آبجکت شما رو میگیره و کلید هارو مقایسه میکنه
                                و در جواب منفی یک ، مثبت 1 و 0 رو برمیرگدونه
                                */


                                const users = {
                                    { name: 'Amir', age: 21 },
                                    { name: 'Jamshid', age: 50 },
                                    { name: 'Zahra', age: 22 },
                                    { name: 'Zeynab', age: 35 },
                                }
                                users.sort((a, b) => {
                                    if (a.age < b.age) return -1
                                    if (a.age > b.age) return 1
                                    return 0
                                })
                                console.log(users)
                                // تابع بالا آبجکت رو بر اساس سن مرتب میکنه
                            </code>
                        </pre>
                        <b>
                            توجه کنید که اینجا ما مقدار بازگشتی منفی یک ، مثبت یک و صفر رو مشخص کردیم ولی توی sort توی اعداد نیازی به مشخص کردن
                            مقدار بازگشتی نیست ، چون 0 که برابر با صفره ، بازگشت اعداد منفی هم مثل منفی یک میمونه و بازگشت اعداد مثبت هم مثل مثبت یک!
                            <br>
                            همچنین توجه کنید که آبجکت های ما داخل یه آرایه قرار دارن ، چون تابع sort روی آرایه ها کار میکنه!
                        </b>
                    </div>
        <h1 id="-exercises">💻 تمرینات</h1>
            <div>
                <ol>
                    <li>تفاوت بین تابع های filter, map, forEach و reduce رو برای خودتون بنویسید و یاد بگیرید</li>
                    <li>تمامی کد های امروز رو خودتون بررسی کنید</li>
                    <li>یه آرایه از اعداد بسازید و تابع هایی که امروز یاد گرفتید رو روشون اجرا کنید.</li>
                    <li>از طریق تابع forEach تمام اعضای آرایه رو ضبدر هم کنید (مجموع ضرب هارو حساب کنید)</li>
                    <li>همین کار بالا رو توی یه آرایه جدید بریزید (map)</li>
                    <li>یه آرایه با اسم چنتا آدم معروف بنویسید (مثلا کریستوفر نولان ، جک دورسی ، عمو جانی و ...)</li>
                    <li>با استفاده از تابع فیلتر اونایی که داخلشون کارکتر m دارنو تو خروجی چاپ کنید</li>
                    <li>چنتا حرکت دیگه هم خودتون بزنید (مثلا چک کنید اسم کی بلند تره یا کوتاه تره)</li>
                    <li>حتما کار با تابع reduce رو تمرین کنید</li>
                    <li>تفاوت find, findIndex رو بفهمید و یه تمرینم براش بنویسید</li>
                    <li>مهم ترین کار امروزتون اینه برای خودتون تمرین ایجاد کنید چون من هرچقدرم تمرین بگم تا خودتون کار نکنید فایده ایی نداره!</li>
                </ol>
            </div>
</article>
<!-- End Article -->

<!-- Start Previous and Next Days -->
<div class="container Pre_Nex mg2b">
    <div class="row">
        <a href="<?= 'day' . $test[1]?>" class="col-xs-5 col-md-2">
            &rarr;
            روز بعدی (
            <?= $test[1] ?>
            )
        </a>
        <div class="col-xs-2 col-md-8"></div>
        <a href="<?= 'day' . $test[0] ?>" class="col-xs-5 col-md-2">
            روز قبلی (
            <?= $test[0] ?>
            )
            &larr;
        </a>
    </div>
</div>
<!-- End Previous and Next Days -->

<!-- END MAIN -->

<!-- Up Button -->
<?php include MAIN_DIR . 'public/Main/Top_Button.php' ?>
<!-- Down Button -->
<?php include MAIN_DIR . 'public/Main/To_Button.php'?>
<!-- Community -->
<?php require MAIN_DIR . "public/Main/Community.php" ?>
<!-- End Community -->
<!-- FOOTER -->
<?php require MAIN_DIR . "public/Main/Footer.php" ?>
<!-- END FOOTER -->


<!-- MAIN SCRIPT -->
<script src="<?= MAIN_SERVER . 'assets/vendor/jquery-3.7.0.min.js' ?>"></script>

<!-- Script For Response Menu -->
<script src="<?= MAIN_SERVER . 'assets/js/Response-Menu.js' ?>"></script>

<!-- Script For Prism -->
<script src="<?= MAIN_SERVER . 'assets/vendor/prism.js' ?>"></script>

<!-- Script Helper -->
<script src="<?= MAIN_SERVER . 'assets/js/Helper.js' ?>"></script>

<!-- File Need It Code -->
<script src="<?= MAIN_SERVER . 'public/30Days/javascript/assets/FileNeedIt.js'?>"></script>

<!-- Scroll Function -->
<script src="<?= MAIN_SERVER . 'public/30Days/javascript/assets/script.js'?>"></script>
<!-- END MAIN SCRIPT-->
</body>
</html>